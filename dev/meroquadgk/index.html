<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MeroQuadGK · IteratedIntegration.jl</title><meta name="title" content="MeroQuadGK · IteratedIntegration.jl"/><meta property="og:title" content="MeroQuadGK · IteratedIntegration.jl"/><meta property="twitter:title" content="MeroQuadGK · IteratedIntegration.jl"/><meta name="description" content="Documentation for IteratedIntegration.jl."/><meta property="og:description" content="Documentation for IteratedIntegration.jl."/><meta property="twitter:description" content="Documentation for IteratedIntegration.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">IteratedIntegration.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../methods/">Manual</a></li><li><a class="tocitem" href="../auxquadgk/">AuxQuadGK</a></li><li class="is-active"><a class="tocitem" href>MeroQuadGK</a><ul class="internal"><li><a class="tocitem" href="#Internal"><span>Internal</span></a></li></ul></li><li><a class="tocitem" href="../contquadgk/">ContQuadGK</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MeroQuadGK</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MeroQuadGK</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lxvm/IteratedIntegration.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lxvm/IteratedIntegration.jl/blob/main/docs/src/meroquadgk.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.MeroQuadGK.few_poly_roots-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector}, Tuple{Vector{T}, Vector{T}, Vector, Int64}} where T" href="#IteratedIntegration.MeroQuadGK.few_poly_roots-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector}, Tuple{Vector{T}, Vector{T}, Vector, Int64}} where T"><code>IteratedIntegration.MeroQuadGK.few_poly_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">roots,rvals = few_poly_roots(c::Vector, vals::Vector, nodes::Vector, n::Int; verb=0)</code></pre><p>Return <code>nr</code> polynomial roots <code>roots</code> given by coefficients <code>c</code>, and <code>rvals</code> corresponding polynomial values.</p><p>Speed goal is 1 us for nr about 3 and degree-14. May use <code>vals</code> function values at <code>nodes</code> which should fill out [-1,1]. Alternates Newton for next root, then deflation to factor it out.</p><p>No failure reporting yet. User should use <code>rvals</code> as quality check.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/064ed26ca6e347dac68e8b6697365971e0077262/src/MeroQuadGK/polesub.jl#L123-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.MeroQuadGK.find_near_roots-Tuple{Vector, Vector, Any, Any, Any}" href="#IteratedIntegration.MeroQuadGK.find_near_roots-Tuple{Vector, Vector, Any, Any, Any}"><code>IteratedIntegration.MeroQuadGK.find_near_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">roots, derivs = find_near_roots(vals, nodes;
                                rho=1.0, fac=nothing, meth=&quot;PR&quot;)</code></pre><p>Returns complex-valued roots of unique polynomial approximant g(z) matching the vector of <code>vals</code> at the vector <code>nodes</code>.  The nodes are assumed to be well-chosen for interpolation on [-1,1]. &#39;roots&#39; are returned in order of increasing (Bernstein) distance from the interval [-1,1]. It also computes &#39;derivs&#39;, the corresponding values of g&#39; at each kept root.</p><p><code>rho &gt; 0.0</code> sets the Bernstein ellipse parameter within which to keep roots. Recall that the ellipse for the standard segment <code>[-1,1]</code> has semiaxes <code>cosh(rho)</code> horizontally and <code>sinh(rho)</code> vertically.</p><p><code>fac</code> allows user to pass in a pre-factorized (eg LU) object for the Vandermonde matrix. This accelerates things by 3us for 15 nodes.</p><p><code>meth</code> controls method for polynomial root-finding:         &quot;PR&quot; - PolynomialRoots.roots()         &quot;PR5&quot; - PolynomialRoots.roots5() degree-5 only (worse perf)         &quot;F&quot; - few<em>poly</em>roots local attempt</p><p>To do:</p><ol><li>template so compiles for known n (speed up roots? poly eval?)</li><li>compare Boyd version using Cheby points (needs twice the degree)</li></ol><p>Alex Barnett 6/29/23 - 7/4/23</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/064ed26ca6e347dac68e8b6697365971e0077262/src/MeroQuadGK/polesub.jl#L70-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.MeroQuadGK.kronrod_vandermonde-Union{Tuple{Vector{T}}, Tuple{T}} where T" href="#IteratedIntegration.MeroQuadGK.kronrod_vandermonde-Union{Tuple{Vector{T}}, Tuple{T}} where T"><code>IteratedIntegration.MeroQuadGK.kronrod_vandermonde</code></a> — <span class="docstring-category">Method</span></header><section><div><p>compute the vandermonde matrix for a symmetric Kronrod rule</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/064ed26ca6e347dac68e8b6697365971e0077262/src/MeroQuadGK/polesub.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.MeroQuadGK.meroquadgk-Tuple{Any, Vararg{Any}}" href="#IteratedIntegration.MeroQuadGK.meroquadgk-Tuple{Any, Vararg{Any}}"><code>IteratedIntegration.MeroQuadGK.meroquadgk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">meroquadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)</code></pre><p>Numerically integrate the function <code>f(x)</code> from <code>a</code> to <code>b</code>, and optionally over additional intervals <code>b</code> to <code>c</code> and so on. Keyword options include a relative error tolerance <code>rtol</code> (if <code>atol==0</code>, defaults to <code>sqrt(eps)</code> in the precision of the endpoints), an absolute error tolerance <code>atol</code> (defaults to 0), a maximum number of function evaluations <code>maxevals</code> (defaults to <code>10^7</code>), and the <code>order</code> of the integration rule (defaults to 7).</p><p>Returns a pair <code>(I,E)</code> of the estimated integral <code>I</code> and an estimated upper bound on the absolute error <code>E</code>. If <code>maxevals</code> is not exceeded then <code>E &lt;= max(atol, rtol*norm(I))</code> will hold. (Note that it is useful to specify a positive <code>atol</code> in cases where <code>norm(I)</code> may be zero.)</p><p>The endpoints <code>a</code> et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are <code>BigFloat</code>, then the integration will be performed in <code>BigFloat</code> precision as well.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is advisable to increase the integration <code>order</code> in rough proportion to the precision, for smooth integrands.</p></div></div><p>More generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).</p><p>The integrand <code>f(x)</code> can return any numeric scalar, vector, or matrix type, or in fact any type supporting <code>+</code>, <code>-</code>, multiplication by real values, and a <code>norm</code> (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a <code>norm</code>-like function as the <code>norm</code> keyword argument (which defaults to <code>norm</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).</p></div></div><p>The algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (<code>2*order+1</code> points) and the error is estimated using an embedded Gauss rule (<code>order</code> points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.</p><p>These quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if <code>f</code> has a discontinuity at <code>x=0.7</code> and you want to integrate from 0 to 1, you should use <code>meroquadgk(f, 0,0.7,1)</code> to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a <code>log(x)</code> or <code>1/sqrt(x)</code> singularity).</p><p>For real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)</p><p>In normal usage, <code>meroquadgk(...)</code> will allocate a buffer for segments. You can instead pass a preallocated buffer allocated using <code>alloc_segbuf(...)</code> as the <code>segbuf</code> argument. This buffer can be used across multiple calls to avoid repeated allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/064ed26ca6e347dac68e8b6697365971e0077262/src/MeroQuadGK/adapt.jl#L77-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.MeroQuadGK.roots_companion-Tuple{AbstractVector{&lt;:Number}}" href="#IteratedIntegration.MeroQuadGK.roots_companion-Tuple{AbstractVector{&lt;:Number}}"><code>IteratedIntegration.MeroQuadGK.roots_companion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">roots_companion(a)

find all complex roots of polynomial a[1]*z^n + a[2]*z^(n-1) + ... + a[n+1]
via companion matrix EVP in O(n^3) time. Similar to MATLAB roots.
Note poly coeffs are in reverse order that in many Julia pkgs.
If the entire C plane is a root, returns [complex(NaN)].

Local reference implementation; superceded by other pkgs.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/064ed26ca6e347dac68e8b6697365971e0077262/src/MeroQuadGK/polesub.jl#L184-L193">source</a></section></article><h2 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h2><p>These functions are internal and may change in future releases of IteratedIntegration.jl</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.MeroQuadGK.kronrod_vandermonde" href="#IteratedIntegration.MeroQuadGK.kronrod_vandermonde"><code>IteratedIntegration.MeroQuadGK.kronrod_vandermonde</code></a> — <span class="docstring-category">Function</span></header><section><div><p>compute the vandermonde matrix for a symmetric Kronrod rule</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/064ed26ca6e347dac68e8b6697365971e0077262/src/MeroQuadGK/polesub.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.MeroQuadGK.few_poly_roots" href="#IteratedIntegration.MeroQuadGK.few_poly_roots"><code>IteratedIntegration.MeroQuadGK.few_poly_roots</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">roots,rvals = few_poly_roots(c::Vector, vals::Vector, nodes::Vector, n::Int; verb=0)</code></pre><p>Return <code>nr</code> polynomial roots <code>roots</code> given by coefficients <code>c</code>, and <code>rvals</code> corresponding polynomial values.</p><p>Speed goal is 1 us for nr about 3 and degree-14. May use <code>vals</code> function values at <code>nodes</code> which should fill out [-1,1]. Alternates Newton for next root, then deflation to factor it out.</p><p>No failure reporting yet. User should use <code>rvals</code> as quality check.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/064ed26ca6e347dac68e8b6697365971e0077262/src/MeroQuadGK/polesub.jl#L123-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.MeroQuadGK.find_near_roots" href="#IteratedIntegration.MeroQuadGK.find_near_roots"><code>IteratedIntegration.MeroQuadGK.find_near_roots</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">roots, derivs = find_near_roots(vals, nodes;
                                rho=1.0, fac=nothing, meth=&quot;PR&quot;)</code></pre><p>Returns complex-valued roots of unique polynomial approximant g(z) matching the vector of <code>vals</code> at the vector <code>nodes</code>.  The nodes are assumed to be well-chosen for interpolation on [-1,1]. &#39;roots&#39; are returned in order of increasing (Bernstein) distance from the interval [-1,1]. It also computes &#39;derivs&#39;, the corresponding values of g&#39; at each kept root.</p><p><code>rho &gt; 0.0</code> sets the Bernstein ellipse parameter within which to keep roots. Recall that the ellipse for the standard segment <code>[-1,1]</code> has semiaxes <code>cosh(rho)</code> horizontally and <code>sinh(rho)</code> vertically.</p><p><code>fac</code> allows user to pass in a pre-factorized (eg LU) object for the Vandermonde matrix. This accelerates things by 3us for 15 nodes.</p><p><code>meth</code> controls method for polynomial root-finding:         &quot;PR&quot; - PolynomialRoots.roots()         &quot;PR5&quot; - PolynomialRoots.roots5() degree-5 only (worse perf)         &quot;F&quot; - few<em>poly</em>roots local attempt</p><p>To do:</p><ol><li>template so compiles for known n (speed up roots? poly eval?)</li><li>compare Boyd version using Cheby points (needs twice the degree)</li></ol><p>Alex Barnett 6/29/23 - 7/4/23</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/064ed26ca6e347dac68e8b6697365971e0077262/src/MeroQuadGK/polesub.jl#L70-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.MeroQuadGK.roots_companion" href="#IteratedIntegration.MeroQuadGK.roots_companion"><code>IteratedIntegration.MeroQuadGK.roots_companion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">roots_companion(a)

find all complex roots of polynomial a[1]*z^n + a[2]*z^(n-1) + ... + a[n+1]
via companion matrix EVP in O(n^3) time. Similar to MATLAB roots.
Note poly coeffs are in reverse order that in many Julia pkgs.
If the entire C plane is a root, returns [complex(NaN)].

Local reference implementation; superceded by other pkgs.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/064ed26ca6e347dac68e8b6697365971e0077262/src/MeroQuadGK/polesub.jl#L184-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.MeroQuadGK.meroquadgk" href="#IteratedIntegration.MeroQuadGK.meroquadgk"><code>IteratedIntegration.MeroQuadGK.meroquadgk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">meroquadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)</code></pre><p>Numerically integrate the function <code>f(x)</code> from <code>a</code> to <code>b</code>, and optionally over additional intervals <code>b</code> to <code>c</code> and so on. Keyword options include a relative error tolerance <code>rtol</code> (if <code>atol==0</code>, defaults to <code>sqrt(eps)</code> in the precision of the endpoints), an absolute error tolerance <code>atol</code> (defaults to 0), a maximum number of function evaluations <code>maxevals</code> (defaults to <code>10^7</code>), and the <code>order</code> of the integration rule (defaults to 7).</p><p>Returns a pair <code>(I,E)</code> of the estimated integral <code>I</code> and an estimated upper bound on the absolute error <code>E</code>. If <code>maxevals</code> is not exceeded then <code>E &lt;= max(atol, rtol*norm(I))</code> will hold. (Note that it is useful to specify a positive <code>atol</code> in cases where <code>norm(I)</code> may be zero.)</p><p>The endpoints <code>a</code> et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are <code>BigFloat</code>, then the integration will be performed in <code>BigFloat</code> precision as well.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is advisable to increase the integration <code>order</code> in rough proportion to the precision, for smooth integrands.</p></div></div><p>More generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).</p><p>The integrand <code>f(x)</code> can return any numeric scalar, vector, or matrix type, or in fact any type supporting <code>+</code>, <code>-</code>, multiplication by real values, and a <code>norm</code> (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a <code>norm</code>-like function as the <code>norm</code> keyword argument (which defaults to <code>norm</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).</p></div></div><p>The algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (<code>2*order+1</code> points) and the error is estimated using an embedded Gauss rule (<code>order</code> points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.</p><p>These quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if <code>f</code> has a discontinuity at <code>x=0.7</code> and you want to integrate from 0 to 1, you should use <code>meroquadgk(f, 0,0.7,1)</code> to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a <code>log(x)</code> or <code>1/sqrt(x)</code> singularity).</p><p>For real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)</p><p>In normal usage, <code>meroquadgk(...)</code> will allocate a buffer for segments. You can instead pass a preallocated buffer allocated using <code>alloc_segbuf(...)</code> as the <code>segbuf</code> argument. This buffer can be used across multiple calls to avoid repeated allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/064ed26ca6e347dac68e8b6697365971e0077262/src/MeroQuadGK/adapt.jl#L77-L136">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../auxquadgk/">« AuxQuadGK</a><a class="docs-footer-nextpage" href="../contquadgk/">ContQuadGK »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Tuesday 14 November 2023 07:26">Tuesday 14 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
