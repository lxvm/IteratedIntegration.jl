<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AuxQuadGK · IteratedIntegration.jl</title><meta name="title" content="AuxQuadGK · IteratedIntegration.jl"/><meta property="og:title" content="AuxQuadGK · IteratedIntegration.jl"/><meta property="twitter:title" content="AuxQuadGK · IteratedIntegration.jl"/><meta name="description" content="Documentation for IteratedIntegration.jl."/><meta property="og:description" content="Documentation for IteratedIntegration.jl."/><meta property="twitter:description" content="Documentation for IteratedIntegration.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">IteratedIntegration.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../methods/">Manual</a></li><li class="is-active"><a class="tocitem" href>AuxQuadGK</a><ul class="internal"><li><a class="tocitem" href="#Internal"><span>Internal</span></a></li></ul></li><li><a class="tocitem" href="../meroquadgk/">MeroQuadGK</a></li><li><a class="tocitem" href="../contquadgk/">ContQuadGK</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>AuxQuadGK</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AuxQuadGK</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lxvm/IteratedIntegration.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lxvm/IteratedIntegration.jl/blob/main/docs/src/auxquadgk.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.AuxQuadGK" href="#IteratedIntegration.AuxQuadGK"><code>IteratedIntegration.AuxQuadGK</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Package for auxiliary integration, i.e. integrating multiple functions at the same time while ensuring that each converges to its own tolerance. This has a few advantages over vector-valued integrands with custom norms in that the errors from different integrands can be treated separated and the adaptive algorithm can decide which integrand to prioritize based on whether others have already converged. This results in conceptually simpler algorithms, especially when the various integrands may differ in order of magnitude.</p><p>This module heavily reuses the source code of QuadGK.jl</p><p><strong>Statement of need</strong></p><p>Calculating integrals of the form a^2/(f(x)^2+a^2)^2 is challenging in the a -&gt; 0 limit because they become extremely localized while also having vanishingly small tails. I.e. the tails are O(a^2) however the integral is O(a^-1). Thus, setting an absolute tolerance is impractical, since the tolerance also needs to be O(a^2) to resolve the tails (otherwise the peaks will be missed) and that may be asking for many more digits than desired. Another option is to specify a relative tolerance, but a failure mode is that if there is more than one peak to integrate, the algorithm may only resolve the first one because the errors in the tails to find the other peaks become eclipsed by the first peak error magnitudes. When the peak positions are known a priori, the convential solution is to pass in several breakpoints to the integration interval so that each interval has at most one peak, but often finding breakpoints can be an expensive precomputation that is better avoided. Instead, an integrand related to the original may more reliably find the peaks without requiring excessive integrand evaluations or being expensive to compute. Returning to the original example, an ideal auxiliary integrand would be 1/(f(x)+im*a)^2, which has O(1) tails and a O(1) integral. Thus the tails will be resolved in order to find the peaks, which don&#39;t need to be resolved to many digits of accuracy. However, since one wants to find the original integral to a certain number of digits, it may be necessary to adapt further after the auxiliary integrand has converged. This is the problem the package aims to solve.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">f(x)    = sin(x)/(cos(x)+im*1e-5)   # peaked &quot;nice&quot; integrand
imf(x)  = imag(f(x))                # peaked difficult integrand
f2(x)   = f(x)^2                    # even more peaked
imf2(x) = imf(x)^2                  # even more peaked!

x0 = 0.1    # arbitrary offset of between peak

function integrand(x)
    re, im = reim(f2(x) + f2(x-x0))
    AuxValue(imf2(x) + imf2(x-x0), re)
end

using QuadGK    # plain adaptive integration

quadgk(x -&gt; imf2(x) + imf2(x-x0), 0, 2pi, atol = 1e-5)   # 1.4271103714584847e-7
quadgk(x -&gt; imf2(x) + imf2(x-x0), 0, 2pi, rtol = 1e-5)   # 235619.45750214785

quadgk(x -&gt; imf2(x), 0, 2pi, rtol = 1e-5)   # 78539.81901117883

quadgk(x -&gt; imf2(x-x0), 0, 2pi, rtol = 1e-5)   # 157079.63263294287

using AuxQuadGK # auxiliary integration

auxquadgk(integrand, 0, 2pi, atol=1e-2) # 628318.5306881254
auxquadgk(integrand, 0, 2pi, rtol=1e-2) # 628318.5306867635</code></pre><p>As can be seen from the example, plain integration can completely fail to capture the integral despite using stringent tolerances. With a well-chosen auxiliary integrand, often arising naturally from the structure of the integrand, the integration is much more robust to error because it can resolve the regions of interest with the more-easily adaptively integrable problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/bc92f8c0d84f7e2b66cdf789a4115344256c6d83/src/AuxQuadGK/AuxQuadGK.jl#L1-L66">source</a></section></article><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.AuxQuadGK.BatchIntegrand" href="#IteratedIntegration.AuxQuadGK.BatchIntegrand"><code>IteratedIntegration.AuxQuadGK.BatchIntegrand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchIntegrand(f!, y::Type, x::Type=Nothing; max_batch=typemax(Int))</code></pre><p>Constructor for a <code>BatchIntegrand</code> whose range type is known. The domain type is optional. Array buffers for those types are allocated internally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/bc92f8c0d84f7e2b66cdf789a4115344256c6d83/src/AuxQuadGK/batch.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.AuxQuadGK.BatchIntegrand" href="#IteratedIntegration.AuxQuadGK.BatchIntegrand"><code>IteratedIntegration.AuxQuadGK.BatchIntegrand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchIntegrand(f!, y::AbstractArray, x::AbstractVector, max_batch=typemax(Int))</code></pre><p>Constructor for a <code>BatchIntegrand</code> accepting an integrand of the form <code>f!(y,x) = y .= f.(x)</code> that can evaluate the integrand at multiple quadrature nodes using, for example, threads, the GPU, or distributed-memory. The <code>max_batch</code> keyword limits the number of nodes passed to the integrand, and it must be at least <code>4*order+2</code> to evaluate two GK rules simultaneously. The buffers <code>y,x</code> must both be <code>resize!</code>-able since the number of evaluation points may vary between calls to <code>f!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/bc92f8c0d84f7e2b66cdf789a4115344256c6d83/src/AuxQuadGK/batch.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.AuxQuadGK.BatchIntegrand-Tuple{Any, Any, Any}" href="#IteratedIntegration.AuxQuadGK.BatchIntegrand-Tuple{Any, Any, Any}"><code>IteratedIntegration.AuxQuadGK.BatchIntegrand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BatchIntegrand(f!, y, x; max_batch=typemax(Int))</code></pre><p>Constructor for a <code>BatchIntegrand</code> with pre-allocated buffers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/bc92f8c0d84f7e2b66cdf789a4115344256c6d83/src/AuxQuadGK/batch.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.AuxQuadGK.auxquadgk!-Tuple{Any, Any, Vararg{Any}}" href="#IteratedIntegration.AuxQuadGK.auxquadgk!-Tuple{Any, Any, Vararg{Any}}"><code>IteratedIntegration.AuxQuadGK.auxquadgk!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">auxquadgk!(f!, result, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm)</code></pre><p>Like <a href="#IteratedIntegration.AuxQuadGK.auxquadgk"><code>auxquadgk</code></a>, but make use of in-place operations for array-valued integrands (or other mutable types supporting in-place operations).  In particular, there are two differences from <code>quadgk</code>:</p><ol><li><p>The function <code>f!</code> should be of the form <code>f!(y, x) = y .= f(x)</code>.  That is, it writes the return value of the integand <code>f(x)</code> in-place into its first argument <code>y</code>.   (The return value of <code>f!</code> is ignored.)</p></li><li><p>Like <code>auxquadgk</code>, the return value is a tuple <code>(I,E)</code> of the estimated integral <code>I</code> and the estimated error <code>E</code>.   However, in <code>auxquadgk!</code> the estimated integral is written in-place into the <code>result</code> argument, so that <code>I === result</code>.</p></li></ol><p>Otherwise, the behavior is identical to <code>auxquadgk</code>.</p><p>For integrands whose values are <em>small</em> arrays whose length is known at compile-time, it is usually more efficient to use <code>quadgk</code> and modify your integrand to return an <code>SVector</code> from the <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl package</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/bc92f8c0d84f7e2b66cdf789a4115344256c6d83/src/AuxQuadGK/adapt.jl#L213-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.AuxQuadGK.auxquadgk!-Tuple{IteratedIntegration.AuxQuadGK.BatchIntegrand, Any, Any}" href="#IteratedIntegration.AuxQuadGK.auxquadgk!-Tuple{IteratedIntegration.AuxQuadGK.BatchIntegrand, Any, Any}"><code>IteratedIntegration.AuxQuadGK.auxquadgk!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">auxquadgk!(f::BatchIntegrand, result, a,b,c...; kws...)</code></pre><p>Like <a href="#IteratedIntegration.AuxQuadGK.auxquadgk!"><code>auxquadgk!</code></a>, but batches evaluation points for an in-place integrand to evaluate simultaneously. In particular, there are two differences from using <code>quadgk</code> with a <code>BatchIntegrand</code>:</p><ol><li><p><code>f.y</code> must be an array of dimension <code>ndims(result)+1</code> whose first <code>axes</code> match those of <code>result</code>. The last dimension of <code>y</code> should be reserved for different Kronrod points, and the function <code>f.f!</code> should be of the form <code>f!(y,x) = foreach((v,z) -&gt; v .= f(z), eachslice(y, dims=ndims(y)), x)</code> or</p><p>function f!(y, x)      idx = CartesianIndices(axes(y)[begin:end-1])      for (j,i) in zip(axes(y)[end], eachindex(x))          y[idx,j] .= f(x[i])      end  end</p></li><li><p><code>f.y</code> must be <code>resize!</code>-able in the last dimension. Consider using <a href="https://github.com/JuliaArrays/ElasticArrays.jl">ElasticArrays.jl</a> for this. Otherwise specialize <code>QuadGK.resizelastdim!(A::T, n)</code> for your array type <code>T</code>.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/bc92f8c0d84f7e2b66cdf789a4115344256c6d83/src/AuxQuadGK/batch.jl#L295-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.AuxQuadGK.auxquadgk-Tuple{Any, Vararg{Any}}" href="#IteratedIntegration.AuxQuadGK.auxquadgk-Tuple{Any, Vararg{Any}}"><code>IteratedIntegration.AuxQuadGK.auxquadgk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">auxquadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)</code></pre><p>Numerically integrate the function <code>f(x)</code> from <code>a</code> to <code>b</code>, and optionally over additional intervals <code>b</code> to <code>c</code> and so on. Keyword options include a relative error tolerance <code>rtol</code> (if <code>atol==0</code>, defaults to <code>sqrt(eps)</code> in the precision of the endpoints), an absolute error tolerance <code>atol</code> (defaults to 0), a maximum number of function evaluations <code>maxevals</code> (defaults to <code>10^7</code>), and the <code>order</code> of the integration rule (defaults to 7).</p><p>Returns a pair <code>(I,E)</code> of the estimated integral <code>I</code> and an estimated upper bound on the absolute error <code>E</code>. If <code>maxevals</code> is not exceeded then <code>E &lt;= max(atol, rtol*norm(I))</code> will hold. (Note that it is useful to specify a positive <code>atol</code> in cases where <code>norm(I)</code> may be zero.)</p><p>Compared to <code>quadgk</code> from QuadGK.jl, <code>auxquadgk</code> implements a few more safeguards for integration of difficult functions. It changes how adaptive refinement is done when using a relative tolerance to refine all segments with an error above the tolerance (instead of just the segment with the largest error). Additionally, if an integrand returns an <code>AuxValue</code> then the heap first integrates the auxiliary value followed by the primary by resorting the heap of segments.</p><p>The endpoints <code>a</code> et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are <code>BigFloat</code>, then the integration will be performed in <code>BigFloat</code> precision as well.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is advisable to increase the integration <code>order</code> in rough proportion to the precision, for smooth integrands.</p></div></div><p>More generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).</p><p>The integrand <code>f(x)</code> can return any numeric scalar, vector, or matrix type, or in fact any type supporting <code>+</code>, <code>-</code>, multiplication by real values, and a <code>norm</code> (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a <code>norm</code>-like function as the <code>norm</code> keyword argument (which defaults to <code>norm</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).</p></div></div><p>The algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (<code>2*order+1</code> points) and the error is estimated using an embedded Gauss rule (<code>order</code> points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.</p><p>These quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if <code>f</code> has a discontinuity at <code>x=0.7</code> and you want to integrate from 0 to 1, you should use <code>auxquadgk(f, 0,0.7,1)</code> to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a <code>log(x)</code> or <code>1/sqrt(x)</code> singularity).</p><p>For real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)</p><p>In normal usage, <code>auxquadgk(...)</code> will allocate a buffer for segments. You can instead pass a preallocated buffer allocated using <code>alloc_segbuf(...)</code> as the <code>segbuf</code> argument. This buffer can be used across multiple calls to avoid repeated allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/bc92f8c0d84f7e2b66cdf789a4115344256c6d83/src/AuxQuadGK/adapt.jl#L136-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.AuxQuadGK.auxquadgk-Union{Tuple{Y}, Tuple{F}, Tuple{IteratedIntegration.AuxQuadGK.BatchIntegrand{F, Y, &lt;:AbstractVector{Nothing}}, Any}} where {F, Y}" href="#IteratedIntegration.AuxQuadGK.auxquadgk-Union{Tuple{Y}, Tuple{F}, Tuple{IteratedIntegration.AuxQuadGK.BatchIntegrand{F, Y, &lt;:AbstractVector{Nothing}}, Any}} where {F, Y}"><code>IteratedIntegration.AuxQuadGK.auxquadgk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">auxquadgk(f::BatchIntegrand, a,b,c...; kws...)</code></pre><p>Like <a href="#IteratedIntegration.AuxQuadGK.auxquadgk"><code>auxquadgk</code></a>, but batches evaluation points for an in-place integrand to evaluate simultaneously. In particular, there are two differences from <code>quadgk</code></p><ol><li><p>The function <code>f.f!</code> should be of the form <code>f!(y, x) = y .= f.(x)</code>.  That is, it writes the return values of the integand <code>f(x)</code> in-place into its first argument <code>y</code>. (The return value of <code>f!</code> is ignored.) See <a href="#IteratedIntegration.AuxQuadGK.BatchIntegrand"><code>BatchIntegrand</code></a> for how to define the integrand.</p></li><li><p><code>f.max_batch</code> must be large enough to contain <code>4*order+2</code> points to evaluate two Kronrod rules simultaneously. Choosing <code>max_batch=4*order+2</code> will reproduce the result of <code>quadgk</code>, however if <code>max_batch=n*(4*order+2)</code> up to <code>2n</code> Kronrod rules will be evaluated together, which can produce different results for integrands with multiple peaks when used together with relative tolerances. For an example see the manual</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/bc92f8c0d84f7e2b66cdf789a4115344256c6d83/src/AuxQuadGK/batch.jl#L272-L288">source</a></section></article><h2 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h2><p>These functions are internal and may change in future releases of IteratedIntegration.jl</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.AuxQuadGK.auxquadgk" href="#IteratedIntegration.AuxQuadGK.auxquadgk"><code>IteratedIntegration.AuxQuadGK.auxquadgk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">auxquadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)</code></pre><p>Numerically integrate the function <code>f(x)</code> from <code>a</code> to <code>b</code>, and optionally over additional intervals <code>b</code> to <code>c</code> and so on. Keyword options include a relative error tolerance <code>rtol</code> (if <code>atol==0</code>, defaults to <code>sqrt(eps)</code> in the precision of the endpoints), an absolute error tolerance <code>atol</code> (defaults to 0), a maximum number of function evaluations <code>maxevals</code> (defaults to <code>10^7</code>), and the <code>order</code> of the integration rule (defaults to 7).</p><p>Returns a pair <code>(I,E)</code> of the estimated integral <code>I</code> and an estimated upper bound on the absolute error <code>E</code>. If <code>maxevals</code> is not exceeded then <code>E &lt;= max(atol, rtol*norm(I))</code> will hold. (Note that it is useful to specify a positive <code>atol</code> in cases where <code>norm(I)</code> may be zero.)</p><p>Compared to <code>quadgk</code> from QuadGK.jl, <code>auxquadgk</code> implements a few more safeguards for integration of difficult functions. It changes how adaptive refinement is done when using a relative tolerance to refine all segments with an error above the tolerance (instead of just the segment with the largest error). Additionally, if an integrand returns an <code>AuxValue</code> then the heap first integrates the auxiliary value followed by the primary by resorting the heap of segments.</p><p>The endpoints <code>a</code> et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are <code>BigFloat</code>, then the integration will be performed in <code>BigFloat</code> precision as well.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is advisable to increase the integration <code>order</code> in rough proportion to the precision, for smooth integrands.</p></div></div><p>More generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).</p><p>The integrand <code>f(x)</code> can return any numeric scalar, vector, or matrix type, or in fact any type supporting <code>+</code>, <code>-</code>, multiplication by real values, and a <code>norm</code> (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a <code>norm</code>-like function as the <code>norm</code> keyword argument (which defaults to <code>norm</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).</p></div></div><p>The algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (<code>2*order+1</code> points) and the error is estimated using an embedded Gauss rule (<code>order</code> points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.</p><p>These quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if <code>f</code> has a discontinuity at <code>x=0.7</code> and you want to integrate from 0 to 1, you should use <code>auxquadgk(f, 0,0.7,1)</code> to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a <code>log(x)</code> or <code>1/sqrt(x)</code> singularity).</p><p>For real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)</p><p>In normal usage, <code>auxquadgk(...)</code> will allocate a buffer for segments. You can instead pass a preallocated buffer allocated using <code>alloc_segbuf(...)</code> as the <code>segbuf</code> argument. This buffer can be used across multiple calls to avoid repeated allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/bc92f8c0d84f7e2b66cdf789a4115344256c6d83/src/AuxQuadGK/adapt.jl#L136-L202">source</a></section><section><div><pre><code class="language-julia hljs">auxquadgk(f::BatchIntegrand, a,b,c...; kws...)</code></pre><p>Like <a href="#IteratedIntegration.AuxQuadGK.auxquadgk"><code>auxquadgk</code></a>, but batches evaluation points for an in-place integrand to evaluate simultaneously. In particular, there are two differences from <code>quadgk</code></p><ol><li><p>The function <code>f.f!</code> should be of the form <code>f!(y, x) = y .= f.(x)</code>.  That is, it writes the return values of the integand <code>f(x)</code> in-place into its first argument <code>y</code>. (The return value of <code>f!</code> is ignored.) See <a href="#IteratedIntegration.AuxQuadGK.BatchIntegrand"><code>BatchIntegrand</code></a> for how to define the integrand.</p></li><li><p><code>f.max_batch</code> must be large enough to contain <code>4*order+2</code> points to evaluate two Kronrod rules simultaneously. Choosing <code>max_batch=4*order+2</code> will reproduce the result of <code>quadgk</code>, however if <code>max_batch=n*(4*order+2)</code> up to <code>2n</code> Kronrod rules will be evaluated together, which can produce different results for integrands with multiple peaks when used together with relative tolerances. For an example see the manual</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/bc92f8c0d84f7e2b66cdf789a4115344256c6d83/src/AuxQuadGK/batch.jl#L272-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IteratedIntegration.AuxQuadGK.auxquadgk!" href="#IteratedIntegration.AuxQuadGK.auxquadgk!"><code>IteratedIntegration.AuxQuadGK.auxquadgk!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">auxquadgk!(f!, result, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm)</code></pre><p>Like <a href="#IteratedIntegration.AuxQuadGK.auxquadgk"><code>auxquadgk</code></a>, but make use of in-place operations for array-valued integrands (or other mutable types supporting in-place operations).  In particular, there are two differences from <code>quadgk</code>:</p><ol><li><p>The function <code>f!</code> should be of the form <code>f!(y, x) = y .= f(x)</code>.  That is, it writes the return value of the integand <code>f(x)</code> in-place into its first argument <code>y</code>.   (The return value of <code>f!</code> is ignored.)</p></li><li><p>Like <code>auxquadgk</code>, the return value is a tuple <code>(I,E)</code> of the estimated integral <code>I</code> and the estimated error <code>E</code>.   However, in <code>auxquadgk!</code> the estimated integral is written in-place into the <code>result</code> argument, so that <code>I === result</code>.</p></li></ol><p>Otherwise, the behavior is identical to <code>auxquadgk</code>.</p><p>For integrands whose values are <em>small</em> arrays whose length is known at compile-time, it is usually more efficient to use <code>quadgk</code> and modify your integrand to return an <code>SVector</code> from the <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl package</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/bc92f8c0d84f7e2b66cdf789a4115344256c6d83/src/AuxQuadGK/adapt.jl#L213-L232">source</a></section><section><div><pre><code class="language-julia hljs">auxquadgk!(f::BatchIntegrand, result, a,b,c...; kws...)</code></pre><p>Like <a href="#IteratedIntegration.AuxQuadGK.auxquadgk!"><code>auxquadgk!</code></a>, but batches evaluation points for an in-place integrand to evaluate simultaneously. In particular, there are two differences from using <code>quadgk</code> with a <code>BatchIntegrand</code>:</p><ol><li><p><code>f.y</code> must be an array of dimension <code>ndims(result)+1</code> whose first <code>axes</code> match those of <code>result</code>. The last dimension of <code>y</code> should be reserved for different Kronrod points, and the function <code>f.f!</code> should be of the form <code>f!(y,x) = foreach((v,z) -&gt; v .= f(z), eachslice(y, dims=ndims(y)), x)</code> or</p><p>function f!(y, x)      idx = CartesianIndices(axes(y)[begin:end-1])      for (j,i) in zip(axes(y)[end], eachindex(x))          y[idx,j] .= f(x[i])      end  end</p></li><li><p><code>f.y</code> must be <code>resize!</code>-able in the last dimension. Consider using <a href="https://github.com/JuliaArrays/ElasticArrays.jl">ElasticArrays.jl</a> for this. Otherwise specialize <code>QuadGK.resizelastdim!(A::T, n)</code> for your array type <code>T</code>.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/IteratedIntegration.jl/blob/bc92f8c0d84f7e2b66cdf789a4115344256c6d83/src/AuxQuadGK/batch.jl#L295-L317">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../methods/">« Manual</a><a class="docs-footer-nextpage" href="../meroquadgk/">MeroQuadGK »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 3 December 2023 04:05">Sunday 3 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
