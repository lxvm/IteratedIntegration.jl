var documenterSearchIndex = {"docs":
[{"location":"contquadgk/#Reference","page":"ContQuadGK","title":"Reference","text":"","category":"section"},{"location":"contquadgk/","page":"ContQuadGK","title":"ContQuadGK","text":"Modules = [IteratedIntegration.ContQuadGK]\nOrder   = [:type, :function]","category":"page"},{"location":"contquadgk/#IteratedIntegration.ContQuadGK.contquadgk-Tuple{Any, Vararg{Any}}","page":"ContQuadGK","title":"IteratedIntegration.ContQuadGK.contquadgk","text":"contquadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)\n\nNumerically integrate the function f(x) from a to b, and optionally over additional intervals b to c and so on. Keyword options include a relative error tolerance rtol (if atol==0, defaults to sqrt(eps) in the precision of the endpoints), an absolute error tolerance atol (defaults to 0), a maximum number of function evaluations maxevals (defaults to 10^7), and the order of the integration rule (defaults to 7).\n\nReturns a pair (I,E) of the estimated integral I and an estimated upper bound on the absolute error E. If maxevals is not exceeded then E <= max(atol, rtol*norm(I)) will hold. (Note that it is useful to specify a positive atol in cases where norm(I) may be zero.)\n\nThe endpoints a et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are BigFloat, then the integration will be performed in BigFloat precision as well.\n\nnote: Note\nIt is advisable to increase the integration order in rough proportion to the precision, for smooth integrands.\n\nMore generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).\n\nThe integrand f(x) can return any numeric scalar, vector, or matrix type, or in fact any type supporting +, -, multiplication by real values, and a norm (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a norm-like function as the norm keyword argument (which defaults to norm).\n\nnote: Note\nOnly one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).\n\nThe algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (2*order+1 points) and the error is estimated using an embedded Gauss rule (order points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.\n\nThese quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if f has a discontinuity at x=0.7 and you want to integrate from 0 to 1, you should use quadgk(f, 0,0.7,1) to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a log(x) or 1/sqrt(x) singularity).\n\nFor real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)\n\nIn normal usage, quadgk(...) will allocate a buffer for segments. You can instead pass a preallocated buffer allocated using alloc_segbuf(...) as the segbuf argument. This buffer can be used across multiple calls to avoid repeated allocation.\n\n\n\n\n\n","category":"method"},{"location":"contquadgk/#IteratedIntegration.ContQuadGK.few_poly_roots-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector}, Tuple{Vector{T}, Vector{T}, Vector, Int64}} where T","page":"ContQuadGK","title":"IteratedIntegration.ContQuadGK.few_poly_roots","text":"roots,rvals = few_poly_roots(c::Vector, vals::Vector, nodes::Vector, n::Int; verb=0)\n\nReturn nr polynomial roots roots given by coefficients c, and rvals corresponding polynomial values.\n\nSpeed goal is 1 us for nr about 3 and degree-14. May use vals function values at nodes which should fill out [-1,1]. Alternates Newton for next root, then deflation to factor it out.\n\nNo failure reporting yet. User should use rvals as quality check.\n\n\n\n\n\n","category":"method"},{"location":"contquadgk/#IteratedIntegration.ContQuadGK.find_near_roots-Tuple{Vector, Vector, Any, Any, Any}","page":"ContQuadGK","title":"IteratedIntegration.ContQuadGK.find_near_roots","text":"roots = find_near_roots(vals, nodes, rho, fac, meth)\n\nReturns complex-valued roots of unique polynomial approximant g(z) matching the vector of vals at the vector nodes.  The nodes are assumed to be well-chosen for interpolation on [-1,1]. 'roots' are returned in order of increasing (Bernstein) distance from the interval [-1,1].\n\nrho > 0.0 sets the Bernstein ellipse parameter within which to keep roots. Recall that the ellipse for the standard segment [-1,1] has semiaxes cosh(rho) horizontally and sinh(rho) vertically.\n\nfac allows user to pass in a pre-factorized (eg LU) object for the Vandermonde matrix. This accelerates things by 3us for 15 nodes.\n\nmeth controls method for polynomial root-finding:         \"PR\" - PolynomialRoots.roots()         \"PR5\" - PolynomialRoots.roots5() degree-5 only (worse perf)         \"F\" - fewpolyroots local attempt\n\nTo do:\n\ntemplate so compiles for known n (speed up roots? poly eval?)\ncompare Boyd version using Cheby points (needs twice the degree)\n\nAlex Barnett 6/29/23 - 7/4/23 edits by LXVM 8/4/23\n\n\n\n\n\n","category":"method"},{"location":"contquadgk/#IteratedIntegration.ContQuadGK.kronrod_vandermonde-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"ContQuadGK","title":"IteratedIntegration.ContQuadGK.kronrod_vandermonde","text":"compute the vandermonde matrix for a symmetric Kronrod rule\n\n\n\n\n\n","category":"method"},{"location":"contquadgk/#IteratedIntegration.ContQuadGK.roots_companion-Tuple{AbstractVector{<:Number}}","page":"ContQuadGK","title":"IteratedIntegration.ContQuadGK.roots_companion","text":"roots_companion(a)\n\nfind all complex roots of polynomial a[1]*z^n + a[2]*z^(n-1) + ... + a[n+1]\nvia companion matrix EVP in O(n^3) time. Similar to MATLAB roots.\nNote poly coeffs are in reverse order that in many Julia pkgs.\nIf the entire C plane is a root, returns [complex(NaN)].\n\nLocal reference implementation; superceded by other pkgs.\n\n\n\n\n\n","category":"method"},{"location":"auxquadgk/","page":"AuxQuadGK","title":"AuxQuadGK","text":"IteratedIntegration.AuxQuadGK","category":"page"},{"location":"auxquadgk/#IteratedIntegration.AuxQuadGK","page":"AuxQuadGK","title":"IteratedIntegration.AuxQuadGK","text":"Package for auxiliary integration, i.e. integrating multiple functions at the same time while ensuring that each converges to its own tolerance. This has a few advantages over vector-valued integrands with custom norms in that the errors from different integrands can be treated separated and the adaptive algorithm can decide which integrand to prioritize based on whether others have already converged. This results in conceptually simpler algorithms, especially when the various integrands may differ in order of magnitude.\n\nThis module heavily reuses the source code of QuadGK.jl\n\nStatement of need\n\nCalculating integrals of the form a^2/(f(x)^2+a^2)^2 is challenging in the a -> 0 limit because they become extremely localized while also having vanishingly small tails. I.e. the tails are O(a^2) however the integral is O(a^-1). Thus, setting an absolute tolerance is impractical, since the tolerance also needs to be O(a^2) to resolve the tails (otherwise the peaks will be missed) and that may be asking for many more digits than desired. Another option is to specify a relative tolerance, but a failure mode is that if there is more than one peak to integrate, the algorithm may only resolve the first one because the errors in the tails to find the other peaks become eclipsed by the first peak error magnitudes. When the peak positions are known a priori, the convential solution is to pass in several breakpoints to the integration interval so that each interval has at most one peak, but often finding breakpoints can be an expensive precomputation that is better avoided. Instead, an integrand related to the original may more reliably find the peaks without requiring excessive integrand evaluations or being expensive to compute. Returning to the original example, an ideal auxiliary integrand would be 1/(f(x)+im*a)^2, which has O(1) tails and a O(1) integral. Thus the tails will be resolved in order to find the peaks, which don't need to be resolved to many digits of accuracy. However, since one wants to find the original integral to a certain number of digits, it may be necessary to adapt further after the auxiliary integrand has converged. This is the problem the package aims to solve.\n\nExample\n\nf(x)    = sin(x)/(cos(x)+im*1e-5)   # peaked \"nice\" integrand\nimf(x)  = imag(f(x))                # peaked difficult integrand\nf2(x)   = f(x)^2                    # even more peaked\nimf2(x) = imf(x)^2                  # even more peaked!\n\nx0 = 0.1    # arbitrary offset of between peak\n\nfunction integrand(x)\n    re, im = reim(f2(x) + f2(x-x0))\n    AuxValue(imf2(x) + imf2(x-x0), re)\nend\n\nusing QuadGK    # plain adaptive integration\n\nquadgk(x -> imf2(x) + imf2(x-x0), 0, 2pi, atol = 1e-5)   # 1.4271103714584847e-7\nquadgk(x -> imf2(x) + imf2(x-x0), 0, 2pi, rtol = 1e-5)   # 235619.45750214785\n\nquadgk(x -> imf2(x), 0, 2pi, rtol = 1e-5)   # 78539.81901117883\n\nquadgk(x -> imf2(x-x0), 0, 2pi, rtol = 1e-5)   # 157079.63263294287\n\nusing AuxQuadGK # auxiliary integration\n\nauxquadgk(integrand, 0, 2pi, atol=1e-2) # 628318.5306881254\nauxquadgk(integrand, 0, 2pi, rtol=1e-2) # 628318.5306867635\n\nAs can be seen from the example, plain integration can completely fail to capture the integral despite using stringent tolerances. With a well-chosen auxiliary integrand, often arising naturally from the structure of the integrand, the integration is much more robust to error because it can resolve the regions of interest with the more-easily adaptively integrable problem.\n\n\n\n\n\n","category":"module"},{"location":"auxquadgk/#Reference","page":"AuxQuadGK","title":"Reference","text":"","category":"section"},{"location":"auxquadgk/","page":"AuxQuadGK","title":"AuxQuadGK","text":"Modules = [IteratedIntegration.AuxQuadGK]\nOrder   = [:type, :function]","category":"page"},{"location":"auxquadgk/#IteratedIntegration.AuxQuadGK.BatchIntegrand","page":"AuxQuadGK","title":"IteratedIntegration.AuxQuadGK.BatchIntegrand","text":"BatchIntegrand(f!, y::Type, x::Type=Nothing; max_batch=typemax(Int))\n\nConstructor for a BatchIntegrand whose range type is known. The domain type is optional. Array buffers for those types are allocated internally.\n\n\n\n\n\n","category":"type"},{"location":"auxquadgk/#IteratedIntegration.AuxQuadGK.BatchIntegrand-2","page":"AuxQuadGK","title":"IteratedIntegration.AuxQuadGK.BatchIntegrand","text":"BatchIntegrand(f!, y::AbstractArray, x::AbstractVector, max_batch=typemax(Int))\n\nConstructor for a BatchIntegrand accepting an integrand of the form f!(y,x) = y .= f.(x) that can evaluate the integrand at multiple quadrature nodes using, for example, threads, the GPU, or distributed-memory. The max_batch keyword limits the number of nodes passed to the integrand, and it must be at least 4*order+2 to evaluate two GK rules simultaneously. The buffers y,x must both be resize!-able since the number of evaluation points may vary between calls to f!.\n\n\n\n\n\n","category":"type"},{"location":"auxquadgk/#IteratedIntegration.AuxQuadGK.BatchIntegrand-Tuple{Any, Any, Any}","page":"AuxQuadGK","title":"IteratedIntegration.AuxQuadGK.BatchIntegrand","text":"BatchIntegrand(f!, y, x; max_batch=typemax(Int))\n\nConstructor for a BatchIntegrand with pre-allocated buffers.\n\n\n\n\n\n","category":"method"},{"location":"auxquadgk/#IteratedIntegration.AuxQuadGK.auxquadgk!-Tuple{Any, Any, Vararg{Any}}","page":"AuxQuadGK","title":"IteratedIntegration.AuxQuadGK.auxquadgk!","text":"auxquadgk!(f!, result, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm)\n\nLike auxquadgk, but make use of in-place operations for array-valued integrands (or other mutable types supporting in-place operations).  In particular, there are two differences from quadgk:\n\nThe function f! should be of the form f!(y, x) = y .= f(x).  That is, it writes the return value of the integand f(x) in-place into its first argument y.   (The return value of f! is ignored.)\nLike auxquadgk, the return value is a tuple (I,E) of the estimated integral I and the estimated error E.   However, in auxquadgk! the estimated integral is written in-place into the result argument, so that I === result.\n\nOtherwise, the behavior is identical to auxquadgk.\n\nFor integrands whose values are small arrays whose length is known at compile-time, it is usually more efficient to use quadgk and modify your integrand to return an SVector from the StaticArrays.jl package.\n\n\n\n\n\n","category":"method"},{"location":"auxquadgk/#IteratedIntegration.AuxQuadGK.auxquadgk!-Tuple{IteratedIntegration.AuxQuadGK.BatchIntegrand, Any, Any}","page":"AuxQuadGK","title":"IteratedIntegration.AuxQuadGK.auxquadgk!","text":"auxquadgk!(f::BatchIntegrand, result, a,b,c...; kws...)\n\nLike auxquadgk!, but batches evaluation points for an in-place integrand to evaluate simultaneously. In particular, there are two differences from using quadgk with a BatchIntegrand:\n\nf.y must be an array of dimension ndims(result)+1 whose first axes match those of result. The last dimension of y should be reserved for different Kronrod points, and the function f.f! should be of the form f!(y,x) = foreach((v,z) -> v .= f(z), eachslice(y, dims=ndims(y)), x) or\nfunction f!(y, x)      idx = CartesianIndices(axes(y)[begin:end-1])      for (j,i) in zip(axes(y)[end], eachindex(x))          y[idx,j] .= f(x[i])      end  end\nf.y must be resize!-able in the last dimension. Consider using ElasticArrays.jl for this. Otherwise specialize QuadGK.resizelastdim!(A::T, n) for your array type T.\n\n\n\n\n\n","category":"method"},{"location":"auxquadgk/#IteratedIntegration.AuxQuadGK.auxquadgk-Tuple{Any, Vararg{Any}}","page":"AuxQuadGK","title":"IteratedIntegration.AuxQuadGK.auxquadgk","text":"auxquadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)\n\nNumerically integrate the function f(x) from a to b, and optionally over additional intervals b to c and so on. Keyword options include a relative error tolerance rtol (if atol==0, defaults to sqrt(eps) in the precision of the endpoints), an absolute error tolerance atol (defaults to 0), a maximum number of function evaluations maxevals (defaults to 10^7), and the order of the integration rule (defaults to 7).\n\nReturns a pair (I,E) of the estimated integral I and an estimated upper bound on the absolute error E. If maxevals is not exceeded then E <= max(atol, rtol*norm(I)) will hold. (Note that it is useful to specify a positive atol in cases where norm(I) may be zero.)\n\nCompared to quadgk from QuadGK.jl, auxquadgk implements a few more safeguards for integration of difficult functions. It changes how adaptive refinement is done when using a relative tolerance to refine all segments with an error above the tolerance (instead of just the segment with the largest error). Additionally, if an integrand returns an AuxValue then the heap first integrates the auxiliary value followed by the primary by resorting the heap of segments.\n\nThe endpoints a et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are BigFloat, then the integration will be performed in BigFloat precision as well.\n\nnote: Note\nIt is advisable to increase the integration order in rough proportion to the precision, for smooth integrands.\n\nMore generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).\n\nThe integrand f(x) can return any numeric scalar, vector, or matrix type, or in fact any type supporting +, -, multiplication by real values, and a norm (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a norm-like function as the norm keyword argument (which defaults to norm).\n\nnote: Note\nOnly one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).\n\nThe algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (2*order+1 points) and the error is estimated using an embedded Gauss rule (order points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.\n\nThese quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if f has a discontinuity at x=0.7 and you want to integrate from 0 to 1, you should use auxquadgk(f, 0,0.7,1) to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a log(x) or 1/sqrt(x) singularity).\n\nFor real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)\n\nIn normal usage, auxquadgk(...) will allocate a buffer for segments. You can instead pass a preallocated buffer allocated using alloc_segbuf(...) as the segbuf argument. This buffer can be used across multiple calls to avoid repeated allocation.\n\n\n\n\n\n","category":"method"},{"location":"auxquadgk/#IteratedIntegration.AuxQuadGK.auxquadgk-Union{Tuple{Y}, Tuple{F}, Tuple{IteratedIntegration.AuxQuadGK.BatchIntegrand{F, Y, <:AbstractVector{Nothing}}, Any}} where {F, Y}","page":"AuxQuadGK","title":"IteratedIntegration.AuxQuadGK.auxquadgk","text":"auxquadgk(f::BatchIntegrand, a,b,c...; kws...)\n\nLike auxquadgk, but batches evaluation points for an in-place integrand to evaluate simultaneously. In particular, there are two differences from quadgk\n\nThe function f.f! should be of the form f!(y, x) = y .= f.(x).  That is, it writes the return values of the integand f(x) in-place into its first argument y. (The return value of f! is ignored.) See BatchIntegrand for how to define the integrand.\nf.max_batch must be large enough to contain 4*order+2 points to evaluate two Kronrod rules simultaneously. Choosing max_batch=4*order+2 will reproduce the result of quadgk, however if max_batch=n*(4*order+2) up to 2n Kronrod rules will be evaluated together, which can produce different results for integrands with multiple peaks when used together with relative tolerances. For an example see the manual\n\n\n\n\n\n","category":"method"},{"location":"auxquadgk/#Internal","page":"AuxQuadGK","title":"Internal","text":"","category":"section"},{"location":"auxquadgk/","page":"AuxQuadGK","title":"AuxQuadGK","text":"These functions are internal and may change in future releases of IteratedIntegration.jl","category":"page"},{"location":"auxquadgk/","page":"AuxQuadGK","title":"AuxQuadGK","text":"IteratedIntegration.AuxQuadGK.auxquadgk\nIteratedIntegration.AuxQuadGK.auxquadgk!","category":"page"},{"location":"auxquadgk/#IteratedIntegration.AuxQuadGK.auxquadgk","page":"AuxQuadGK","title":"IteratedIntegration.AuxQuadGK.auxquadgk","text":"auxquadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)\n\nNumerically integrate the function f(x) from a to b, and optionally over additional intervals b to c and so on. Keyword options include a relative error tolerance rtol (if atol==0, defaults to sqrt(eps) in the precision of the endpoints), an absolute error tolerance atol (defaults to 0), a maximum number of function evaluations maxevals (defaults to 10^7), and the order of the integration rule (defaults to 7).\n\nReturns a pair (I,E) of the estimated integral I and an estimated upper bound on the absolute error E. If maxevals is not exceeded then E <= max(atol, rtol*norm(I)) will hold. (Note that it is useful to specify a positive atol in cases where norm(I) may be zero.)\n\nCompared to quadgk from QuadGK.jl, auxquadgk implements a few more safeguards for integration of difficult functions. It changes how adaptive refinement is done when using a relative tolerance to refine all segments with an error above the tolerance (instead of just the segment with the largest error). Additionally, if an integrand returns an AuxValue then the heap first integrates the auxiliary value followed by the primary by resorting the heap of segments.\n\nThe endpoints a et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are BigFloat, then the integration will be performed in BigFloat precision as well.\n\nnote: Note\nIt is advisable to increase the integration order in rough proportion to the precision, for smooth integrands.\n\nMore generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).\n\nThe integrand f(x) can return any numeric scalar, vector, or matrix type, or in fact any type supporting +, -, multiplication by real values, and a norm (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a norm-like function as the norm keyword argument (which defaults to norm).\n\nnote: Note\nOnly one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).\n\nThe algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (2*order+1 points) and the error is estimated using an embedded Gauss rule (order points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.\n\nThese quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if f has a discontinuity at x=0.7 and you want to integrate from 0 to 1, you should use auxquadgk(f, 0,0.7,1) to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a log(x) or 1/sqrt(x) singularity).\n\nFor real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)\n\nIn normal usage, auxquadgk(...) will allocate a buffer for segments. You can instead pass a preallocated buffer allocated using alloc_segbuf(...) as the segbuf argument. This buffer can be used across multiple calls to avoid repeated allocation.\n\n\n\n\n\nauxquadgk(f::BatchIntegrand, a,b,c...; kws...)\n\nLike auxquadgk, but batches evaluation points for an in-place integrand to evaluate simultaneously. In particular, there are two differences from quadgk\n\nThe function f.f! should be of the form f!(y, x) = y .= f.(x).  That is, it writes the return values of the integand f(x) in-place into its first argument y. (The return value of f! is ignored.) See BatchIntegrand for how to define the integrand.\nf.max_batch must be large enough to contain 4*order+2 points to evaluate two Kronrod rules simultaneously. Choosing max_batch=4*order+2 will reproduce the result of quadgk, however if max_batch=n*(4*order+2) up to 2n Kronrod rules will be evaluated together, which can produce different results for integrands with multiple peaks when used together with relative tolerances. For an example see the manual\n\n\n\n\n\n","category":"function"},{"location":"auxquadgk/#IteratedIntegration.AuxQuadGK.auxquadgk!","page":"AuxQuadGK","title":"IteratedIntegration.AuxQuadGK.auxquadgk!","text":"auxquadgk!(f!, result, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm)\n\nLike auxquadgk, but make use of in-place operations for array-valued integrands (or other mutable types supporting in-place operations).  In particular, there are two differences from quadgk:\n\nThe function f! should be of the form f!(y, x) = y .= f(x).  That is, it writes the return value of the integand f(x) in-place into its first argument y.   (The return value of f! is ignored.)\nLike auxquadgk, the return value is a tuple (I,E) of the estimated integral I and the estimated error E.   However, in auxquadgk! the estimated integral is written in-place into the result argument, so that I === result.\n\nOtherwise, the behavior is identical to auxquadgk.\n\nFor integrands whose values are small arrays whose length is known at compile-time, it is usually more efficient to use quadgk and modify your integrand to return an SVector from the StaticArrays.jl package.\n\n\n\n\n\nauxquadgk!(f::BatchIntegrand, result, a,b,c...; kws...)\n\nLike auxquadgk!, but batches evaluation points for an in-place integrand to evaluate simultaneously. In particular, there are two differences from using quadgk with a BatchIntegrand:\n\nf.y must be an array of dimension ndims(result)+1 whose first axes match those of result. The last dimension of y should be reserved for different Kronrod points, and the function f.f! should be of the form f!(y,x) = foreach((v,z) -> v .= f(z), eachslice(y, dims=ndims(y)), x) or\nfunction f!(y, x)      idx = CartesianIndices(axes(y)[begin:end-1])      for (j,i) in zip(axes(y)[end], eachindex(x))          y[idx,j] .= f(x[i])      end  end\nf.y must be resize!-able in the last dimension. Consider using ElasticArrays.jl for this. Otherwise specialize QuadGK.resizelastdim!(A::T, n) for your array type T.\n\n\n\n\n\n","category":"function"},{"location":"meroquadgk/#Reference","page":"MeroQuadGK","title":"Reference","text":"","category":"section"},{"location":"meroquadgk/","page":"MeroQuadGK","title":"MeroQuadGK","text":"Modules = [IteratedIntegration.MeroQuadGK]\nOrder   = [:type, :function]","category":"page"},{"location":"meroquadgk/#IteratedIntegration.MeroQuadGK.few_poly_roots-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector}, Tuple{Vector{T}, Vector{T}, Vector, Int64}} where T","page":"MeroQuadGK","title":"IteratedIntegration.MeroQuadGK.few_poly_roots","text":"roots,rvals = few_poly_roots(c::Vector, vals::Vector, nodes::Vector, n::Int; verb=0)\n\nReturn nr polynomial roots roots given by coefficients c, and rvals corresponding polynomial values.\n\nSpeed goal is 1 us for nr about 3 and degree-14. May use vals function values at nodes which should fill out [-1,1]. Alternates Newton for next root, then deflation to factor it out.\n\nNo failure reporting yet. User should use rvals as quality check.\n\n\n\n\n\n","category":"method"},{"location":"meroquadgk/#IteratedIntegration.MeroQuadGK.find_near_roots-Tuple{Vector, Vector, Any, Any, Any}","page":"MeroQuadGK","title":"IteratedIntegration.MeroQuadGK.find_near_roots","text":"roots, derivs = find_near_roots(vals, nodes;\n                                rho=1.0, fac=nothing, meth=\"PR\")\n\nReturns complex-valued roots of unique polynomial approximant g(z) matching the vector of vals at the vector nodes.  The nodes are assumed to be well-chosen for interpolation on [-1,1]. 'roots' are returned in order of increasing (Bernstein) distance from the interval [-1,1]. It also computes 'derivs', the corresponding values of g' at each kept root.\n\nrho > 0.0 sets the Bernstein ellipse parameter within which to keep roots. Recall that the ellipse for the standard segment [-1,1] has semiaxes cosh(rho) horizontally and sinh(rho) vertically.\n\nfac allows user to pass in a pre-factorized (eg LU) object for the Vandermonde matrix. This accelerates things by 3us for 15 nodes.\n\nmeth controls method for polynomial root-finding:         \"PR\" - PolynomialRoots.roots()         \"PR5\" - PolynomialRoots.roots5() degree-5 only (worse perf)         \"F\" - fewpolyroots local attempt\n\nTo do:\n\ntemplate so compiles for known n (speed up roots? poly eval?)\ncompare Boyd version using Cheby points (needs twice the degree)\n\nAlex Barnett 6/29/23 - 7/4/23\n\n\n\n\n\n","category":"method"},{"location":"meroquadgk/#IteratedIntegration.MeroQuadGK.kronrod_vandermonde-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"MeroQuadGK","title":"IteratedIntegration.MeroQuadGK.kronrod_vandermonde","text":"compute the vandermonde matrix for a symmetric Kronrod rule\n\n\n\n\n\n","category":"method"},{"location":"meroquadgk/#IteratedIntegration.MeroQuadGK.meroquadgk-Tuple{Any, Vararg{Any}}","page":"MeroQuadGK","title":"IteratedIntegration.MeroQuadGK.meroquadgk","text":"meroquadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)\n\nNumerically integrate the function f(x) from a to b, and optionally over additional intervals b to c and so on. Keyword options include a relative error tolerance rtol (if atol==0, defaults to sqrt(eps) in the precision of the endpoints), an absolute error tolerance atol (defaults to 0), a maximum number of function evaluations maxevals (defaults to 10^7), and the order of the integration rule (defaults to 7).\n\nReturns a pair (I,E) of the estimated integral I and an estimated upper bound on the absolute error E. If maxevals is not exceeded then E <= max(atol, rtol*norm(I)) will hold. (Note that it is useful to specify a positive atol in cases where norm(I) may be zero.)\n\nThe endpoints a et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are BigFloat, then the integration will be performed in BigFloat precision as well.\n\nnote: Note\nIt is advisable to increase the integration order in rough proportion to the precision, for smooth integrands.\n\nMore generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).\n\nThe integrand f(x) can return any numeric scalar, vector, or matrix type, or in fact any type supporting +, -, multiplication by real values, and a norm (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a norm-like function as the norm keyword argument (which defaults to norm).\n\nnote: Note\nOnly one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).\n\nThe algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (2*order+1 points) and the error is estimated using an embedded Gauss rule (order points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.\n\nThese quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if f has a discontinuity at x=0.7 and you want to integrate from 0 to 1, you should use meroquadgk(f, 0,0.7,1) to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a log(x) or 1/sqrt(x) singularity).\n\nFor real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)\n\nIn normal usage, meroquadgk(...) will allocate a buffer for segments. You can instead pass a preallocated buffer allocated using alloc_segbuf(...) as the segbuf argument. This buffer can be used across multiple calls to avoid repeated allocation.\n\n\n\n\n\n","category":"method"},{"location":"meroquadgk/#IteratedIntegration.MeroQuadGK.roots_companion-Tuple{AbstractVector{<:Number}}","page":"MeroQuadGK","title":"IteratedIntegration.MeroQuadGK.roots_companion","text":"roots_companion(a)\n\nfind all complex roots of polynomial a[1]*z^n + a[2]*z^(n-1) + ... + a[n+1]\nvia companion matrix EVP in O(n^3) time. Similar to MATLAB roots.\nNote poly coeffs are in reverse order that in many Julia pkgs.\nIf the entire C plane is a root, returns [complex(NaN)].\n\nLocal reference implementation; superceded by other pkgs.\n\n\n\n\n\n","category":"method"},{"location":"meroquadgk/#Internal","page":"MeroQuadGK","title":"Internal","text":"","category":"section"},{"location":"meroquadgk/","page":"MeroQuadGK","title":"MeroQuadGK","text":"These functions are internal and may change in future releases of IteratedIntegration.jl","category":"page"},{"location":"meroquadgk/","page":"MeroQuadGK","title":"MeroQuadGK","text":"IteratedIntegration.MeroQuadGK.kronrod_vandermonde\nIteratedIntegration.MeroQuadGK.few_poly_roots\nIteratedIntegration.MeroQuadGK.find_near_roots\nIteratedIntegration.MeroQuadGK.roots_companion\nIteratedIntegration.MeroQuadGK.meroquadgk","category":"page"},{"location":"meroquadgk/#IteratedIntegration.MeroQuadGK.kronrod_vandermonde","page":"MeroQuadGK","title":"IteratedIntegration.MeroQuadGK.kronrod_vandermonde","text":"compute the vandermonde matrix for a symmetric Kronrod rule\n\n\n\n\n\n","category":"function"},{"location":"meroquadgk/#IteratedIntegration.MeroQuadGK.few_poly_roots","page":"MeroQuadGK","title":"IteratedIntegration.MeroQuadGK.few_poly_roots","text":"roots,rvals = few_poly_roots(c::Vector, vals::Vector, nodes::Vector, n::Int; verb=0)\n\nReturn nr polynomial roots roots given by coefficients c, and rvals corresponding polynomial values.\n\nSpeed goal is 1 us for nr about 3 and degree-14. May use vals function values at nodes which should fill out [-1,1]. Alternates Newton for next root, then deflation to factor it out.\n\nNo failure reporting yet. User should use rvals as quality check.\n\n\n\n\n\n","category":"function"},{"location":"meroquadgk/#IteratedIntegration.MeroQuadGK.find_near_roots","page":"MeroQuadGK","title":"IteratedIntegration.MeroQuadGK.find_near_roots","text":"roots, derivs = find_near_roots(vals, nodes;\n                                rho=1.0, fac=nothing, meth=\"PR\")\n\nReturns complex-valued roots of unique polynomial approximant g(z) matching the vector of vals at the vector nodes.  The nodes are assumed to be well-chosen for interpolation on [-1,1]. 'roots' are returned in order of increasing (Bernstein) distance from the interval [-1,1]. It also computes 'derivs', the corresponding values of g' at each kept root.\n\nrho > 0.0 sets the Bernstein ellipse parameter within which to keep roots. Recall that the ellipse for the standard segment [-1,1] has semiaxes cosh(rho) horizontally and sinh(rho) vertically.\n\nfac allows user to pass in a pre-factorized (eg LU) object for the Vandermonde matrix. This accelerates things by 3us for 15 nodes.\n\nmeth controls method for polynomial root-finding:         \"PR\" - PolynomialRoots.roots()         \"PR5\" - PolynomialRoots.roots5() degree-5 only (worse perf)         \"F\" - fewpolyroots local attempt\n\nTo do:\n\ntemplate so compiles for known n (speed up roots? poly eval?)\ncompare Boyd version using Cheby points (needs twice the degree)\n\nAlex Barnett 6/29/23 - 7/4/23\n\n\n\n\n\n","category":"function"},{"location":"meroquadgk/#IteratedIntegration.MeroQuadGK.roots_companion","page":"MeroQuadGK","title":"IteratedIntegration.MeroQuadGK.roots_companion","text":"roots_companion(a)\n\nfind all complex roots of polynomial a[1]*z^n + a[2]*z^(n-1) + ... + a[n+1]\nvia companion matrix EVP in O(n^3) time. Similar to MATLAB roots.\nNote poly coeffs are in reverse order that in many Julia pkgs.\nIf the entire C plane is a root, returns [complex(NaN)].\n\nLocal reference implementation; superceded by other pkgs.\n\n\n\n\n\n","category":"function"},{"location":"meroquadgk/#IteratedIntegration.MeroQuadGK.meroquadgk","page":"MeroQuadGK","title":"IteratedIntegration.MeroQuadGK.meroquadgk","text":"meroquadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)\n\nNumerically integrate the function f(x) from a to b, and optionally over additional intervals b to c and so on. Keyword options include a relative error tolerance rtol (if atol==0, defaults to sqrt(eps) in the precision of the endpoints), an absolute error tolerance atol (defaults to 0), a maximum number of function evaluations maxevals (defaults to 10^7), and the order of the integration rule (defaults to 7).\n\nReturns a pair (I,E) of the estimated integral I and an estimated upper bound on the absolute error E. If maxevals is not exceeded then E <= max(atol, rtol*norm(I)) will hold. (Note that it is useful to specify a positive atol in cases where norm(I) may be zero.)\n\nThe endpoints a et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are BigFloat, then the integration will be performed in BigFloat precision as well.\n\nnote: Note\nIt is advisable to increase the integration order in rough proportion to the precision, for smooth integrands.\n\nMore generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).\n\nThe integrand f(x) can return any numeric scalar, vector, or matrix type, or in fact any type supporting +, -, multiplication by real values, and a norm (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a norm-like function as the norm keyword argument (which defaults to norm).\n\nnote: Note\nOnly one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).\n\nThe algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (2*order+1 points) and the error is estimated using an embedded Gauss rule (order points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.\n\nThese quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if f has a discontinuity at x=0.7 and you want to integrate from 0 to 1, you should use meroquadgk(f, 0,0.7,1) to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a log(x) or 1/sqrt(x) singularity).\n\nFor real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)\n\nIn normal usage, meroquadgk(...) will allocate a buffer for segments. You can instead pass a preallocated buffer allocated using alloc_segbuf(...) as the segbuf argument. This buffer can be used across multiple calls to avoid repeated allocation.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Reference","page":"Manual","title":"Reference","text":"","category":"section"},{"location":"methods/","page":"Manual","title":"Manual","text":"Modules = [IteratedIntegration]\nOrder   = [:type, :function]","category":"page"},{"location":"methods/#IteratedIntegration.AbstractIteratedLimits","page":"Manual","title":"IteratedIntegration.AbstractIteratedLimits","text":"AbstractIteratedLimits{d,T}\n\nSupertype for limits of integration over a domain with elements of type SVector{d,T}. In order to work with iterated integration, the following methods must be implemented\n\nInterface\n\nsegments: returns an iterator over intervals to integrate in the current dimension\nfixandeliminate: return another limit object with one of the variables of integration eliminated\n\nthe domain of integration must be convex.\n\n\n\n\n\n","category":"type"},{"location":"methods/#IteratedIntegration.CubicLimits","page":"Manual","title":"IteratedIntegration.CubicLimits","text":"CubicLimits(a, b)\n\nStore integration limit information for a hypercube with vertices a and b. which can be can be real numbers, tuples, or AbstractVectors. The outermost variable of integration corresponds to the last entry.\n\n\n\n\n\n","category":"type"},{"location":"methods/#IteratedIntegration.ProductLimits","page":"Manual","title":"IteratedIntegration.ProductLimits","text":"ProductLimits(lims::AbstractIteratedLimits...)\n\nConstruct a collection of limits which yields the first limit followed by the second, and so on. The inner limits are not allowed to depend on the outer ones. The outermost variable of integration should be placed first, i.e. int_Omega int_Gamma should be ProductLimits(Ω, Γ). Although changing the order of the limits should not change the results, putting the shortest limits first may save nested_quadgk some work.\n\n\n\n\n\n","category":"type"},{"location":"methods/#IteratedIntegration.TetrahedralLimits","page":"Manual","title":"IteratedIntegration.TetrahedralLimits","text":"TetrahedralLimits(a::NTuple{d}) where d\n\nA parametrization of the integration limits for a tetrahedron whose vertices are\n\n( 0.0,  0.0, ...,  0.0)\n( 0.0,  0.0, ..., a[d])\n…\n( 0.0, a[2], ..., a[d])\n(a[1], a[2], ..., a[d])\n\n\n\n\n\n","category":"type"},{"location":"methods/#IteratedIntegration.TranslatedLimits","page":"Manual","title":"IteratedIntegration.TranslatedLimits","text":"TranslatedLimits(lims::AbstractIteratedLimits{d}, t::NTuple{d}) where d\n\nReturns the limits of lims translated by offsets in t.\n\n\n\n\n\n","category":"type"},{"location":"methods/#IteratedIntegration.fixandeliminate","page":"Manual","title":"IteratedIntegration.fixandeliminate","text":"fixandeliminate(l::AbstractIteratedLimits, x)\n\nFix the outermost variable of integration and return the inner limits.\n\nnote: For developers\nRealizations of type T<:AbstractIteratedLimits only have to implement a method with signature fixandeliminate(::T, ::Number). The result must also have dimension one less than the input, and this should only be called when ndims= 1\n\n\n\n\n\n","category":"function"},{"location":"methods/#IteratedIntegration.load_limits","page":"Manual","title":"IteratedIntegration.load_limits","text":"load_limits(obj)\n\nLoad integration limits from an object. Serves as an api hook for package extensions with specialized limit types.\n\n\n\n\n\n","category":"function"},{"location":"methods/#IteratedIntegration.nested_quad-Tuple{Any, Any, Any}","page":"Manual","title":"IteratedIntegration.nested_quad","text":"nested_quad(f, a, b; kwargs...)\nnested_quad(f, l::AbstractIteratedLimits{d,T}; routine=quadgk, kwargs...) where {d,T}\n\nCalls QuadGK to perform iterated 1D integration of f over a compact domain parametrized by AbstractIteratedLimits l. In the case two points a and b are passed, the integration region becomes the hypercube with those extremal vertices (which mimics hcubature).\n\nReturns a tuple (I, E) of the estimated integral and estimated error.\n\nKeyword options include a relative error tolerance rtol (if atol==0, defaults to sqrt(eps) in the precision of the norm of the return type), an absolute error tolerance atol (defaults to 0), a maximum number of function evaluations maxevals for each nested integral (defaults to 10^7), and the order of the integration rule (defaults to 7).\n\nThe algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (2*order+1 points) and the error is estimated using an embedded Gauss rule (order points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved. This 1D procedure is applied recursively to each variable of integration in an order determined by l to obtain the multi-dimensional integral.\n\n\n\n\n\n","category":"method"},{"location":"methods/#IteratedIntegration.segments","page":"Manual","title":"IteratedIntegration.segments","text":"segments(::AbstractLimits, dim)\n\nReturn an iterator over endpoints and breakpoints in the limits along dimension dim. They must be sorted.\n\n\n\n\n\n","category":"function"},{"location":"#IteratedIntegration.jl","page":"Home","title":"IteratedIntegration.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IteratedIntegration","category":"page"},{"location":"#IteratedIntegration","page":"Home","title":"IteratedIntegration","text":"A package for iterated adaptive integration (IAI) based on QuadGK.jl. Its main exports are nested_quad, a routine which performs multidimensional adaptive integration with nested quadgk calls and the AbstractIteratedLimits abstraction to evaluate parametrizations of limits of integration.\n\n\n\n\n\n","category":"module"}]
}
